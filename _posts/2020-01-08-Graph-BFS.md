---
layout: post
title:  "Graph Shortest Path"
date:   2020-01-08 08:35:00 +0530
categories: algorithm graph BFS ShortestPath
---
A graph models a set of connections. Graphs are made up of nodes and edges. A node can be directly connected to many other nodes. Those nodes are called its neighbors. 

`A tree is a special type of graph, where no edges ever point back.`

## BREADTH-FIRST SEARCH

BFS can help answer two types of questions:

1. Is there a path from node A to node B?

2. What is the shortest path from node A to node B?

Even though we are talking about BFS of Graph here, the traversal technique applies to Trees as well. We will try to understand Tree traversal first and build on top of that strategy to understand Graph traversal. There are only two classic ways to traverse a Binary Tree iteratively - Breadth First and Depth First. BFS uses a Queue while DFS uses a Stack. We will get into the details of why it is that way in a minute.

In BFS or Breadth First Search traversal, the aim is to visit or process your neighbouring nodes first followed by it's neighbouring nodes. To say it in another way, visit your friends first followed by FOF's (friends friend).

	  (1)
	  / \
	(2) (3)
          \
          (4)

Consider the tree above with root node (1), when we do BFS traversal, the aim is to visit the immediate neighbours first, So we start from (1) which is the root node, followed by it's two immediate neighbours (2) and (3) followed by (4), which is (3)'s neighbour. Now the question is whether to use Queue or stack for this?

When we do a graph or tree traversal, what we are essentially doing is, visit a node, collect all it's adjacent nodes and put it into a bag for later processing. 

{% highlight html %}
1. Add root node to bag.
2. Pick the next node from bag for processing.
3. Process the node.
3. Add all it's childerns to the bag.
4. Continue to #2.
{% endhighlight %}

Now, if you think about our requirement for BFS, our aim is to process (2) and (3) ahead of (4). Basically we want to process the nodes in the same order that we encountered them... which means, First Encountered node must be Processed First. We need a FIFO datastructure for the bag which is Queue.

If you can understand this, then you can easily understand why DFS requires a Stack. In DFS we what to process the last encountered node first. So the processing order will be (4) followed by (3) followed by (2) followed by (1).

Now, coming back to the Graph from where we started. The only difference between Graph and Tree traversal is, Graph traversal requires an additional datastructure to keep track of visited nodes. Otherwise we will end up in infinite loops. Usually a hashtable will be used to mark a node as visited to avoid duplicate processing and cycles. We will understand this more when we look at the actual code.

Now we will look at some code for BFS of Tree. BFS is also known as Level Order Traversal. As the name indicates, 

{% highlight python %}
class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None
        
def BFS(root):
    if root is None:
        return
    q = []
    q.append(root)
    
    while q:
        nodeToBeProcessed = q.pop(0)
        print(nodeToBeProcessed.data)
        if nodeToBeProcessed.left:
            q.append(nodeToBeProcessed.left)
        if nodeToBeProcessed.right:    
            q.append(nodeToBeProcessed.right)

#Main
root = Node(1)
root.left=Node(2)
root.right=Node(3)
root.right.left=Node(4)

BFS(root)
{% endhighlight %}

You may tryout this code and visualize the execution [here][python-tutor].

The output of executing this code is given below. 

{% highlight html %}
1
2
3
4
{% endhighlight %}

You may have noticed that it is not really printing the output in level order. Ideal Level order traversal output is this one.

{% highlight html %}
1
2,3
4
{% endhighlight %}

Let's try to modify the above code to print the output in level order. In order to do that we need to keep track of the level associated with each node. Which means, instead of just putting the node into the queue, we will have to put the node and it's level into the queue.

{% highlight python %}
class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None
        
def BFS(root):
    if root is None:
        return
    q = []
    level = 0
    q.append((root, level))
    previousLevel = 0
    
    while q:
        nodeToBeProcessed, level = q.pop(0)
        
        #Logic to print a newline after each level
        if level != previousLevel:
            print("")
            previousLevel = level
            
        print(nodeToBeProcessed.data, end =",")
        if nodeToBeProcessed.left:
            q.append((nodeToBeProcessed.left, level+1))
        if nodeToBeProcessed.right:    
            q.append((nodeToBeProcessed.right, level+1))

#Main
root = Node(1)
root.left=Node(2)
root.right=Node(3)
root.right.left=Node(4)

BFS(root)
{% endhighlight %}

The above code produces an output of this form. To keep things simple let's ignore the extra "," at the end for now.

{% highlight html %}
1,
2,3,
4,
{% endhighlight %}

[Inspired by this blog] [firecode-io].

[firecode-io]: https://www.firecode.io/blog/7-java-problem-of-the-week---minimum-depth-of-a-tree

[python-tutor]: http://www.pythontutor.com/live.html#code=class%20Node%3A%0A%20%20%20%20def%20__init__%28self,%20data%29%3A%0A%20%20%20%20%20%20%20%20self.data%20%3D%20data%0A%20%20%20%20%20%20%20%20self.left%20%3D%20None%0A%20%20%20%20%20%20%20%20self.right%20%3D%20None%0A%20%20%20%20%20%20%20%20%0Adef%20BFS%28root%29%3A%0A%20%20%20%20if%20root%20is%20None%3A%0A%20%20%20%20%20%20%20%20return%0A%20%20%20%20q%20%3D%20%5B%5D%0A%20%20%20%20q.append%28root%29%0A%20%20%20%20%0A%20%20%20%20while%20q%3A%0A%20%20%20%20%20%20%20%20nodeToBeProcessed%20%3D%20q.pop%280%29%0A%20%20%20%20%20%20%20%20print%28nodeToBeProcessed.data%29%0A%20%20%20%20%20%20%20%20if%20nodeToBeProcessed.left%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20q.append%28nodeToBeProcessed.left%29%0A%20%20%20%20%20%20%20%20if%20nodeToBeProcessed.right%3A%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20q.append%28nodeToBeProcessed.right%29%0A%0A%23Main%0Aroot%20%3D%20Node%281%29%0Aroot.left%3DNode%282%29%0Aroot.right%3DNode%283%29%0Aroot.right.left%3DNode%284%29%0A%0ABFS%28root%29&cumulative=false&curInstr=56&heapPrimitives=nevernest&mode=display&origin=opt-live.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false